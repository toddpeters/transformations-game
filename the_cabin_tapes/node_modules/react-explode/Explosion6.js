"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _gsap = require("gsap");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Explosion = function (_Component) {
    _inherits(Explosion, _Component);

    function Explosion() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, Explosion);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Explosion.__proto__ || Object.getPrototypeOf(Explosion)).call.apply(_ref, [this].concat(args))), _this), _this.paths = [], _this.circles = [], _this.left = 2.5, _this.height = 3.75, _this.sliced = 10, _this.center = _this.props.size / 2, _this.degree = 360, _this.ratio = 25, _this.radius = 6.5, _this.animateBubbles = function () {
            var size = _this.props.size;
            var ease = _gsap.Power4.easeOut;
            var origins = [[300, 50], [300, 0], [-200, 50]];
            var timelines = [];

            for (var i = 0; i < _this.circles.length; i++) {
                var circle = _this.circles[i];
                var origin = origins[i];
                var timeline = new _gsap.TimelineMax({ delay: (i + 1) / 5 });

                timeline.from(circle, 1, { scale: 0, transformOrigin: "center", ease: ease });
                timeline.to(circle, 1.5, { rotation: 120, transformOrigin: origin[0] + "% " + origin[1] + "%", ease: ease }, "-=0.9");
                timeline.to(circle, 0.5, { opacity: 0 }, "-=1");

                timelines.push(timeline);
            }

            return timelines;
        }, _this.animateShape = function () {
            var ease = _gsap.Power4.easeOut;
            var size = _this.props.size;
            var left = size * _this.left / 100;
            var sliced = size * _this.sliced / 100;
            var timelines = [];

            for (var i = 0; i < _this.paths.length; i++) {
                var path = _this.paths[i];
                var percent = sliced * 100 / (size - left * 2) / 2;
                var transformOrigin = 50 + percent + "% 50%";
                var degree = i % 2 == 0 ? _this.degree + _this.ratio : -(_this.degree - _this.ratio);
                var rotation = degree * ((i + 1) / 4);

                var timeline = new _gsap.TimelineMax();

                timeline.from(path, 1.5, { scale: 0, transformOrigin: transformOrigin, ease: ease });
                timeline.to(path, 0.9, { rotation: rotation, ease: ease }, "-=1.5");
                timeline.to(path, 0.5, { scale: 0, ease: ease });

                timelines.push(timeline);
            }

            return timelines;
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(Explosion, [{
        key: "componentDidMount",
        value: function componentDidMount() {
            var _props = this.props,
                _props$delay = _props.delay,
                delay = _props$delay === undefined ? 0 : _props$delay,
                _props$repeat = _props.repeat,
                repeat = _props$repeat === undefined ? 0 : _props$repeat,
                _props$repeatDelay = _props.repeatDelay,
                repeatDelay = _props$repeatDelay === undefined ? 0 : _props$repeatDelay,
                onStart = _props.onStart,
                onComplete = _props.onComplete,
                onRepeat = _props.onRepeat;

            var tl = new _gsap.TimelineMax({ delay: delay, repeat: repeat, repeatDelay: repeatDelay, onStart: onStart, onComplete: onComplete, onRepeat: onRepeat });

            tl.add(this.animateShape(), 0);
            tl.add(this.animateBubbles(), "-=2");
        }
    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                size = _props2.size,
                style = _props2.style;

            var height = size * this.height / 100;
            var left = size * this.left / 100;
            var sliced = size * this.sliced / 100;
            var top = this.center - height;
            var bottom = this.center + height;
            var right = size - left - sliced;
            var shape = "\n            M " + left + "   " + top + "\n            L " + this.center + " " + this.center + "\n            L " + right + "  " + bottom + "\n            L " + right + "  " + top + "\n            L " + this.center + " " + this.center + "\n            L " + left + "   " + bottom + "\n        ";
            var strokeWidth = Math.ceil(size * 0.5 / 100);

            return _react2.default.createElement(
                "svg",
                { width: size, height: size, style: style },
                [].concat(_toConsumableArray(Array(4))).map(function (_, i) {
                    return _react2.default.createElement(
                        _react.Fragment,
                        { key: i },
                        _react2.default.createElement("path", {
                            ref: function ref(el) {
                                return _this2.paths[i] = el;
                            },
                            d: shape,
                            stroke: "white",
                            strokeWidth: strokeWidth,
                            fill: "white"
                        }),
                        i <= 2 && _react2.default.createElement("circle", {
                            cx: _this2.center,
                            cy: _this2.center,
                            r: size * _this2.radius / 100,
                            ref: function ref(el) {
                                return _this2.circles[i] = el;
                            },
                            stroke: "white",
                            strokeWidth: strokeWidth,
                            fill: "none"
                        })
                    );
                })
            );
        }
    }]);

    return Explosion;
}(_react.Component);

exports.default = Explosion;
